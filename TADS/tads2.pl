use strict;			# 'Safest' operation level
use warnings;		# Give warnings

##Version History
my $Decompiler_Version		= 0.5;
#v0.1:	Initial structure for flow and storage
#v0.2:	Parsing of data blocks (Headers + XSI/OBJ/RES)
#v0.3:	Generation and parsing of symbol file
#v0.4:	Verbose mode implementation, parsing of VOC/CMPD/FMTSTR
#v0.5:	Action analyzis and property decoding

##Global variables##
#File handling
my $FileName_Input;		# Filename for the compiled gamefile to decompile
my $FileName_Mapping;	# Filename for the mapping/translation file, if any.
my $FileName_Generate;	# Filename for the generated mapping file
my $FileName_Path;		# Path to place output files in
my $FileName_Output;	# Filename for the resulting sourcecode
my $FileName_Log;		# Filename for the decompilation log
my $File_Input;			# File handle for input compiled gamefile
my $File_Mapping;		# File handle for name mapping
my $File_Output;		# File handle for output decompiled sourcecode
my $File_Log;			# File handle for logging output

#Option handling
my $Option_Minimal;		# Skip output directory and embedded resources
my $Option_Generate;	# Generate a new symbol file
my $Option_Verbose;		# Extra information dumped to story file
my $Options	= "Available Options:\n";
$Options	.= "-m\t\tMinimalist mode: Skip resources and output directory\n";
$Options	.= "-s [file]:\tSymbol file: Parse the file for symbol mappings\n";
$Options	.= "+s\t\tGenerate symbol file: Store symbol mapping in output directory\n";

#TADS Constants
my $Size_Header				= 48;
my $Size_Signature			= 11;
my $Signature_TADS2_Game	= chr(84).chr(65).chr(68).chr(83).chr(50).chr(32).chr( 98).chr(105).chr(110).chr(10).chr(13);
my $Signature_TADS2_Res		= chr(84).chr(65).chr(68).chr(83).chr(50).chr(32).chr(114).chr(115).chr( 99).chr(10).chr(13);
my $Encryption_Seed			= 0x3f;
my $Encryption_Increment	= 0x40;
my $Null_Value				= 65535;

#Names corresponding to the property types
sub namePropertyType($){
	my $type = shift;
	if ($type eq 1)		{return 'number'}
	if ($type eq 2) 	{return 'object'}
	if ($type eq 3)		{return 's-string'}
	if ($type eq 4)		{return 'baseptr'}
	if ($type eq 5)		{return 'nil'}
	if ($type eq 6)		{return 'code'}
	if ($type eq 7)		{return 'list'}
	if ($type eq 8)		{return 'true'}
	if ($type eq 9)		{return 'd-string'}
	if ($type eq 10)	{return 'fnaddr'}
	if ($type eq 11)	{return 'tpl'}
	if ($type eq 13)	{return 'property'}
	if ($type eq 14)	{return 'demand'}
	if ($type eq 15)	{return 'synonym'}
	if ($type eq 16)	{return 'redir'}
	if ($type eq 17)	{return 'tpl2'}
	return "unknown ($type)";
}

#Game Details
my $Flag_SymbolTable;		# include symbol table in output file
my $Flags_SourceTracking;	# include source file tracking information
my $Flags_Preinit;			# preinit needs to be run after reading game
my $Flags_Encrypted;		# 'encrypt' objects prior to writing them
my $Flags_Precompiled;		# writing precompiled header
my $Flags_Fastload;			# fast-load records are in file
my $Flags_CaseFolding;		# case folding was turned on in original compile
my $Flags_NewStyleLine;		# new-style line records

#Game Contents
my @Objects 			= ();	# Array of hash-map representing the decompiled objects
my @Formats				= ();	# Array of strings storing the formated strings
my @Compounds 			= ();	# Array of strings storing the compunded tokens

##Translation
#Start points; used for skipping printing of basic objects and properties
my $Translate_Property_Start = 0;	# Property ID to start autogenerated symbol mapping from.
my $Translate_Object_Start = 0;		# Object ID to start autogenerated symbol mapping from.
#Mappings
my @Translate_Action			= ();	# Names for actions aren't stored anywhere
my @Translate_Builtin			= ();
my @Translate_Object			= ();
my @Translate_Object_Argument	= ();
my @Translate_Object_Local		= ();
my @Translate_Property			= ();
my @Translate_Property_Argument	= ();
my @Translate_Property_Local	= ();
#Namings
sub nameAction($) {
	my $id = shift;
	return $Translate_Action[$id]	if defined $Translate_Action[$id];
	return "Action$id";
}
sub nameBuiltin($) {
	my $id = shift;
	return $Translate_Builtin[$id]	if defined $Translate_Builtin[$id];
	return "Builtin$id";
}
sub nameObject($) {
	my $id = shift;
	return 'nullObj'				if ($id eq $Null_Value);
	return $Translate_Object[$id]	if defined $Translate_Object[$id];
	return "Obj$id";
}
sub nameProperty($) {
	my $id = shift;
	return 'nullprop'				if ($id eq $Null_Value);
	return $Translate_Property[$id] if defined $Translate_Property[$id];
	return "prop$id";
}
sub nameArgument($$) {
	my $id		= shift;	# Negative for object functions, positive for properties
	my $value	= shift;	# Negative for arguments, positive for locals
	# Locals; loc1 is stored at index 0, etc
	if ($value > 0) {
		my $local	= $value;
		if ($id > 0) {	# Properties
			return $Translate_Property_Local[$id][$local - 1]	if defined $Translate_Property_Local[$id][$local - 1];
		} else {		# Functions
			return $Translate_Object_Local[-$id][$local - 1]	if defined $Translate_Object_Local[-$id][$local - 1];
		}
		return "local$local";
	}
	# Arguments; arg1 is stored at index 0, etc
	else {
		my $arg		= -1 * $value;
		if ($id > 0) {	# Properties
			return $Translate_Property_Argument[$id][$arg - 1]	if defined $Translate_Property_Argument[$id][$arg - 1];
		} else {		# Functions
			return $Translate_Object_Argument[-$id][$arg - 1]	if defined $Translate_Object_Argument[-$id][$arg - 1];
		}
		return "arg$arg";
	}
}
#Mapping File Handling
sub preloadMapping(){
	#Names for builtins and constant properties are taken from detads by Daniel Schepler
	$Translate_Property[1]	= 'doAction';
	$Translate_Property[2]	= 'verb';
	$Translate_Property[3]	= 'noun';
	$Translate_Property[4]	= 'adjective';
	$Translate_Property[5]	= 'preposition';
	$Translate_Property[6]	= 'article';
	$Translate_Property[7]	= 'plural';
	$Translate_Property[8]	= 'sdesc';
	$Translate_Property[9]	= 'thedesc';
	$Translate_Property[10]	= 'doDefault';
	$Translate_Property[11]	= 'ioDefault';
	$Translate_Property[12]	= 'ioAction';
	$Translate_Property[13]	= 'location';
	$Translate_Property[14]	= 'value';
	$Translate_Property[15]	= 'roomAction';
	$Translate_Property[16]	= 'actorAction';
	$Translate_Property[17]	= 'contents';
	$Translate_Property[18]	= 'tpl';
	$Translate_Property[19]	= 'prepDefault';
	$Translate_Property[20]	= 'verActor';
	$Translate_Property[21]	= 'validDo';
	$Translate_Property[22]	= 'validIo';
	$Translate_Property[23]	= 'lookAround';
	$Translate_Property[24]	= 'roomCheck';
	$Translate_Property[25]	= 'statusLine';
	$Translate_Property[26]	= 'locationOK';
	$Translate_Property[27]	= 'isVisible';
	$Translate_Property[28]	= 'cantReach';
	$Translate_Property[29]	= 'isHim';
	$Translate_Property[30]	= 'isHer';
	$Translate_Property[31]	= 'action';
	$Translate_Property[32]	= 'validDoList';
	$Translate_Property[33]	= 'validIoList';
	$Translate_Property[34]	= 'iobjGen';
	$Translate_Property[35]	= 'dobjGen';
	$Translate_Property[36]	= 'nilPrep';
	$Translate_Property[37]	= 'rejectMultiDobj';
	$Translate_Property[38]	= 'moveInto';
	$Translate_Property[39]	= 'construct';
	$Translate_Property[40]	= 'destruct';
	$Translate_Property[41]	= 'validActor';
	$Translate_Property[42]	= 'preferredActor';
	$Translate_Property[43]	= 'isEquivalent';
	$Translate_Property[44]	= 'adesc';
	$Translate_Property[45]	= 'multisdesc';
	$Translate_Property[46]	= 'tpl2';
	$Translate_Property[47]	= 'anyvalue';
	$Translate_Property[48]	= 'newNumbered';
	$Translate_Property[49]	= 'unknown';
	$Translate_Property[50]	= 'parseUnknownDobj';
	$Translate_Property[51]	= 'parseUnknownIobj';
	$Translate_Property[52]	= 'dobjCheck';
	$Translate_Property[53]	= 'iobjCheck';
	$Translate_Property[54]	= 'verbAction';
	$Translate_Property[55]	= 'disambigDobj';
	$Translate_Property[56]	= 'disambigIobj';
	$Translate_Property[57]	= 'prefixdesc';
	$Translate_Property[58]	= 'isThem';
	#Argument names
	$Translate_Property_Argument[10] = ['actor', 'prep', 'iobj'];					# doDefault
	$Translate_Property_Argument[11] = ['actor', 'prep'];							# ioDefault
	$Translate_Property_Argument[14] = ['actor', 'verb', 'dobj', 'prep', 'iobj'];	# roomAction
	$Translate_Property_Argument[15] = ['verb', 'dobj', 'prep', 'iobj'];			# actorAction
	$Translate_Property_Argument[21] = ['actor', 'obj', 'seqno'];					# validDo
	$Translate_Property_Argument[22] = ['actor', 'obj', 'seqno'];					# validIo
	$Translate_Property_Argument[23] = ['verbosity'];								# lookAround
	$Translate_Property_Argument[24] = ['verb'];									# roomCheck
	$Translate_Property_Argument[27] = ['vantage'];									# isVisible
	$Translate_Property_Argument[28] = ['actor', 'dolist', 'iolist', 'prep'];		# cantReach
	$Translate_Property_Argument[31] = ['actor'];									# action
	$Translate_Property_Argument[32] = ['actor', 'prep', 'iobj'];					# validDoList
	$Translate_Property_Argument[33] = ['actor', 'prep', 'dobj'];					# validIoList
	$Translate_Property_Argument[34] = ['actor', 'verb', 'dobj', 'prep'];			# iobjGen
	$Translate_Property_Argument[35] = ['actor', 'verb', 'iobj', 'prep'];			# dobjGen
	# BUGFIX: #36 (undefined) was missing
	$Translate_Property_Argument[37] = ['prep'];									# rejectMultiDobj
	$Translate_Property_Argument[38] = ['dest'];									# moveInto
	$Translate_Property_Argument[47] = ['num'];										# anyvalue
	$Translate_Property_Argument[48] = ['actor', 'verb', 'num'];					# newNumbered
	$Translate_Property_Argument[50] = ['actor', 'prep', 'iobj', 'wordlist'];		# parseUnknownDobj
	$Translate_Property_Argument[51] = ['actor', 'prep', 'iobj', 'wordlist'];		# parseUnknownIobj
	$Translate_Property_Argument[52] = ['actor', 'prep', 'iobj', 'prep'];			# dobjCheck
	$Translate_Property_Argument[53] = ['actor', 'prep', 'iobj', 'prep'];			# iobjCheck
	$Translate_Property_Argument[54] = ['actor', 'dobj', 'prep', 'iobj'];			# verbAction
	$Translate_Property_Argument[55] = ['actor', 'prep', 'iobj', 'verprop', 'wordlist', 'objlist', 'flaglist', 'numberWanted', 'isAmbiguous', 'silent'];	# disambigDobj
	$Translate_Property_Argument[56] = ['actor', 'prep', 'dobj', 'verprop', 'wordlist', 'objlist', 'flaglist', 'numberWanted', 'isAmbiguous', 'silent'];	# disambigIobj
	$Translate_Property_Argument[57] = ['show', 'current_index', 'count', 'multi_flags'];	# prefixdesc
	#Builtin functions
	$Translate_Builtin[0]	= 'say'; 
	$Translate_Builtin[1]	= 'car'; 
	$Translate_Builtin[2]	= 'cdr'; 
	$Translate_Builtin[3]	= 'length'; 
	$Translate_Builtin[4]	= 'randomize'; 
	$Translate_Builtin[5]	= 'rand'; 
	$Translate_Builtin[6]	= 'substr'; 
	$Translate_Builtin[7]	= 'cvtstr'; 
	$Translate_Builtin[8]	= 'cvtnum'; 
	$Translate_Builtin[9]	= 'upper'; 
	$Translate_Builtin[10]	= 'lower'; 
	$Translate_Builtin[11]	= 'caps'; 
	$Translate_Builtin[12]	= 'find'; 
	$Translate_Builtin[13]	= 'getarg'; 
	$Translate_Builtin[14]	= 'datatype'; 
	$Translate_Builtin[15]	= 'setdaemon'; 
	$Translate_Builtin[16]	= 'setfuse'; 
	$Translate_Builtin[17]	= 'setversion'; 
	$Translate_Builtin[18]	= 'notify'; 
	$Translate_Builtin[19]	= 'unnotify'; 
	$Translate_Builtin[20]	= 'yorn'; 
	$Translate_Builtin[21]	= 'remfuse'; 
	$Translate_Builtin[22]	= 'remdaemon'; 
	$Translate_Builtin[23]	= 'incturn'; 
	$Translate_Builtin[24]	= 'quit'; 
	$Translate_Builtin[25]	= 'save'; 
	$Translate_Builtin[26]	= 'restore'; 
	$Translate_Builtin[27]	= 'logging'; 
	$Translate_Builtin[28]	= 'input'; 
	$Translate_Builtin[29]	= 'setit'; 
	$Translate_Builtin[30]	= 'askfile'; 
	$Translate_Builtin[31]	= 'setscore'; 
	$Translate_Builtin[32]	= 'firstobj'; 
	$Translate_Builtin[33]	= 'nextobj'; 
	$Translate_Builtin[34]	= 'isclass'; 
	$Translate_Builtin[35]	= 'restart';
	$Translate_Builtin[36]	= 'debugTrace'; 
	$Translate_Builtin[37]	= 'undo'; 
	$Translate_Builtin[38]	= 'defined'; 
	$Translate_Builtin[39]	= 'proptype'; 
	$Translate_Builtin[40]	= 'outhide'; 
	$Translate_Builtin[41]	= 'runfuses'; 
	$Translate_Builtin[42]	= 'rundaemons'; 
	$Translate_Builtin[43]	= 'gettime'; 
	$Translate_Builtin[44]	= 'getfuse'; 
	$Translate_Builtin[45]	= 'intersect'; 
	$Translate_Builtin[46]	= 'inputkey'; 
	$Translate_Builtin[47]	= 'objwords'; 
	$Translate_Builtin[48]	= 'addword'; 
	$Translate_Builtin[49]	= 'delword'; 
	$Translate_Builtin[50]	= 'getwords'; 
	$Translate_Builtin[51]	= 'nocaps'; 
	$Translate_Builtin[52]	= 'skipturn'; 
	$Translate_Builtin[53]	= 'clearscreen'; 
	$Translate_Builtin[54]	= 'firstsc'; 
	$Translate_Builtin[55]	= 'verbinfo'; 
	$Translate_Builtin[56]	= 'fopen'; 
	$Translate_Builtin[57]	= 'fclose'; 
	$Translate_Builtin[58]	= 'fwrite'; 
	$Translate_Builtin[59]	= 'fread'; 
	$Translate_Builtin[60]	= 'fseek'; 
	$Translate_Builtin[61]	= 'fseekeof'; 
	$Translate_Builtin[62]	= 'ftell'; 
	$Translate_Builtin[63]	= 'outcapture'; 
	$Translate_Builtin[64]	= 'systemInfo'; 
	$Translate_Builtin[65]	= 'morePrompt'; 
	$Translate_Builtin[66]	= 'parserSetMe'; 
	$Translate_Builtin[67]	= 'parserGetMe'; 
	$Translate_Builtin[68]	= 'reSearch'; 
	$Translate_Builtin[69]	= 'reGetGroup'; 
	$Translate_Builtin[70]	= 'inputevent'; 
	$Translate_Builtin[71]	= 'timeDelay'; 
	$Translate_Builtin[72]	= 'setOutputFilter'; 
	$Translate_Builtin[73]	= 'execCommand'; 
	$Translate_Builtin[74]	= 'parserGetObj'; 
	$Translate_Builtin[75]	= 'parseNounList'; 
	$Translate_Builtin[76]	= 'parserTokenize'; 
	$Translate_Builtin[77]	= 'parserGetTokTypes';
	$Translate_Builtin[78]	= 'parserDictLookup'; 
	$Translate_Builtin[79]	= 'parserResolveObjects';
	$Translate_Builtin[80]	= 'parserReplaceCommand'; 
	$Translate_Builtin[81]	= 'exitobj'; 
	$Translate_Builtin[82]	= 'inputdialog'; 
	$Translate_Builtin[83]	= 'resourceExists';
}
sub parseMapping(){
	open($File_Mapping, "< :raw :bytes", $FileName_Mapping)
		|| die("Couldn't open $FileName_Mapping for reading.");
	my $line;
	while ($line = <$File_Mapping>){
		#Pre-process the line
		chomp $line;
		next if $line eq '';					# Skip empty lines
		next if (substr($line, 0, 1) eq '#');	# Skip full-line comments
		$line	= (split('#', $line))[0];		# Remove comments
		my $parsed;
		#Builtins are not translated
		if($line =~ m/(Action|Act)s?\[?(\d*)\]?\s*=\s*['"](.*)['"]/i ){
			$parsed 					= $3;
			$Translate_Action[$2]		= $parsed;
		}
		if($line =~ m/(Object|Obj)s?\[?(\d*)\]?\s*=\s*['"](.*)['"]/i ){
			$parsed 					= $3;
			$Translate_Object[$2]		= $parsed;
		}
		if($line =~ m/(Object|Obj)s?[-_]?(Arg|Argument)?\[?(\d*)[.-](\d*)\]?\s*=\s*['"](.*)['"]/i ){
			$parsed 									= $5;
			$Translate_Object_Argument[$3][$4 - 1]	= $parsed;
		}
		if($line =~ m/(Object|Obj)s?[-_]?(Loc|Local)?\[?(\d*)[.-](\d*)\]?\s*=\s*['"](.*)['"]/i ){
			$parsed 									= $5;
			$Translate_Object_Local[$3][$4 - 1]		= $parsed;
		}
		if($line =~ m/(Property|Properties|Props|Prop)\[?(\d*)\]?\s*=\s*['"](.*)['"]/i ){
			$parsed 					= $3;
			$Translate_Property[$2]		= $parsed;
		}
		if($line =~ m/(Property|Props|Prop)[-_]?(Arg|Argument)?\[?(\d*)[.-](\d*)\]?\s*=\s*['"](.*)['"]/i ){
			$parsed 									= $5;
			$Translate_Property_Argument[$3][$4 - 1]	= $parsed;
		}
		if($line =~ m/(Property|Props|Prop)[-_]?(Loc|Local)?\[?(\d*)[.-](\d*)\]?\s*=\s*['"](.*)['"]/i ){
			$parsed 									= $5;
			$Translate_Property_Local[$3][$4 - 1]		= $parsed;
		}
		print "Unable to parse $line\n" unless defined $parsed;
	}
	close $File_Mapping;
}
sub generateMapping(){
	open($File_Mapping, "> :raw :bytes", $FileName_Path . $FileName_Generate)
		|| die "$0: can't open " . $FileName_Path . $FileName_Generate . "for writing: $!";
	print $File_Mapping "#Actions\n";
	for (my $action=0 ; $action<$#Translate_Action ; $action++){
		print $File_Mapping '#' unless defined $Translate_Action[$action];
		print $File_Mapping "Action$action\t= '";
		print $File_Mapping nameAction($action) if defined $Translate_Action[$action];
		print $File_Mapping "'\n";
	}
	#Builtins are skipped on purpose
	print $File_Mapping "#Objects\n";
	for my $obj ( $Translate_Object_Start .. $#Translate_Object) {
		if (defined $Translate_Object[$obj]){
			print $File_Mapping "Obj$obj\t= '" . nameObject($obj) . "'\n";
			if (defined $Translate_Object_Argument[$obj]){
				for my $arg ( 0 .. $#{ $Translate_Object_Argument[$obj] } ) {
					print $File_Mapping "\tObjArg$obj-".($arg+1)."\t= '$Translate_Object_Argument[$obj][$arg]'\n" if defined $Translate_Object_Argument[$obj][$arg];
				}
			}
			if (defined $Translate_Object_Local[$obj]){
				for my $loc ( 0 .. $#{ $Translate_Object_Local[$obj] } ) {
					print $File_Mapping "\tObjLoc$obj-".($loc+1)."\t= '$Translate_Object_Local[$obj][$loc]'\n" if defined $Translate_Object_Local[$obj][$loc];
				}
			}
		}
	}
	print $File_Mapping "#Properties\n";
	for my $prop ( $Translate_Property_Start .. $#Translate_Property) {
		if (defined $Translate_Property[$prop]){
			print $File_Mapping "Prop$prop\t= '" . nameProperty($prop) . "'\n";
			if (defined $Translate_Property_Argument[$prop]){
				for my $arg ( 0 .. $#{ $Translate_Property_Argument[$prop] } ) {
					print $File_Mapping "\tPropArg$prop-".($arg+1)."\t= '$Translate_Property_Argument[$prop][$arg]'\n" if defined $Translate_Property_Argument[$prop][$arg];
				}
			}
			if (defined $Translate_Property_Local[$prop]){
				for my $loc ( 0 .. $#{ $Translate_Property_Local[$prop] } ) {
					print $File_Mapping "\tPropLoc$prop-".($loc+1)."\t= '$Translate_Property_Local[$prop][$loc]'\n" if defined $Translate_Property_Local[$prop][$loc];
				}
			}
		}
	}
	close $File_Mapping;
}
##File Handling
#Decrypts the block of text passed in
sub decrypt($){
	return unless $Flags_Encrypted;
	my $block	= shift;
	my $size	= length($block);
	my $mask	= $Encryption_Seed;
	my $block_mask;
	for my $i (1 .. $size) {
		$block_mask	.= chr($mask);
		$mask		= ($mask + $Encryption_Increment) % 256;
	}
	return $block ^ $block_mask;
}
sub debug($;$){
	my $block	= shift;
	my $id		= shift;
	my $size	= length $block;
	print $File_Log "Debug dump for $id\n"	if defined $id;
	for (my $i=0 ; $i<$size ; $i++) {
		my $char	= substr($block, $i, 1);
		my $byte	= ord($char);
		$char		= '' if $byte > 128 || $byte < 32;
		my $int		= '';
		$int		= unpack('S', substr($block, $i, 2)) if $i < ($size-1);
		print $File_Log "\t$i\t$byte\t$char\t$int\n"
	}
}

##Parsing
sub parseHeader(){
	#The header is 48 bytes long
	#	 0-10	File header signature
	#	11-12	Reserved but unused (?)
	#	13-18	Compiler version (?)
	#	19-20	Flags
	#	   21	Unknown
	#	22-45	Build date
	#	46-47	Unknown
	my $block_header;
	my $bytes_read = read ($File_Input, $block_header, $Size_Header);
	die "Unable to read file header." unless $bytes_read eq $Size_Header;
	#Check the signature
	my $signature	= substr($block_header, 0, $Size_Signature);
	die "$FileName_Input is not a valid TADS file."
		unless	$signature eq $Signature_TADS2_Game
			||	$signature eq $Signature_TADS2_Res;
	#Parse the rest of the header
	my $unknown1	= unpack('S', substr($block_header, 11, 2));	# substr($block_header, 11, 2);
	my $version		= substr($block_header, 13, 6);
	my $flags		= unpack('n', substr($block_header, 19, 2));	# Flags are stored as a bitmap, so read in as big-endian UINT-16
#	my $flags		= unpack('C', substr($block_header, 20, 1));	# Flags might be stored only in byte 19 though...
	my $unknown2	= unpack('C', substr($block_header, 21, 1));	# substr($block_header, 21, 1);
	my $timestamp	= substr($block_header, 22, 24);
	my $unknown3	= unpack('S', substr($block_header, 46, 2));	# substr($block_header, 46, 2);
	#Parse Flags
	$Flag_SymbolTable		=	$flags & 1;
	$Flags_SourceTracking	=	$flags & 2;
	$Flags_Preinit			=	$flags & 4;
	$Flags_Encrypted		=	$flags & 8;
	$Flags_Precompiled		=	$flags & 16;
	$Flags_Fastload			=	$flags & 32;
	$Flags_CaseFolding		=	$flags & 64;
	$Flags_NewStyleLine		=	$flags & 128;
	#Write to log
	print $File_Log "Decompiler v$Decompiler_Version on $FileName_Input ";
	print $File_Log "(a TADS2-Game file)\n"		if $signature eq $Signature_TADS2_Game;
	print $File_Log "(a TADS2-Resource file)\n"	if $signature eq $Signature_TADS2_Res;
	print $File_Log "Compiled by $version at $timestamp\n";
	print $File_Log "\tUnknown 1: $unknown1\n"	if $Option_Verbose;
	print $File_Log "\tUnknown 2: $unknown2\n"	if $Option_Verbose;
	print $File_Log "\tUnknown 3: $unknown3\n"	if $Option_Verbose;
	print $File_Log "\tEnabled flags ($flags):\n";
	print $File_Log "\t\tInclude symbol table in output file\n"				if $Flag_SymbolTable;
	print $File_Log "\t\tInclude source file tracking information\n"		if $Flags_SourceTracking;
	print $File_Log "\t\tPreinit needs to be run after reading game\n"		if $Flags_Preinit;
	print $File_Log "\t\t'encrypt' objects prior to writing them\n"			if $Flags_Encrypted;
	print $File_Log "\t\tWriting precompiled header\n"						if $Flags_Precompiled;
	print $File_Log "\t\tFast-load records are in file\n"					if $Flags_Fastload;
	print $File_Log "\t\tCase folding was turned on in original compile\n"	if $Flags_CaseFolding;
	print $File_Log "\t\tNew-style line records\n"							if $Flags_NewStyleLine;
}
sub parseFile(){
	#The compiled file consists of several blocks of varying length.
	for (;;){
		#Each block starts with a header of varying length
		my $size_type;	# 1 byte; size of the type field
		my $block_type;	# X bytes as defined by size_type; the type of data block
		my $next_block;	# 4 bytes; location of the next block.
		my $block_size;
		my $block;
		read ($File_Input, $size_type, 1);
		read ($File_Input, $block_type, unpack('C', $size_type));
		read ($File_Input, $next_block, 4);
		$block_size	= unpack('L', $next_block) - tell($File_Input);
		#Log the block type, and break out at the end of the file.
		print $File_Log "$block_type: $block_size bytes\n";
		last unless $block_size;
		last if	$block_type eq '$EOF';
		#read the contents of the block and parse it
		read ($File_Input, $block, $block_size);
		if	($block_type eq 'XSI')		{ parseBlockXSI($block) }		# XOR Seed Information
		if	($block_type eq 'OBJ')		{ parseBlockOBJ($block) }		# OBJects
		#FST	Fast load information; does not contain anything useful for decompilation
		#INH	Inheritances; not parsed
		if	($block_type eq 'FMTSTR')	{ parseBlockFMTSTR($block) }	# Format Strings
		if	($block_type eq 'REQ')		{ parseBlockREQ($block) }		# REQuired (?)
		if	($block_type eq 'CMPD')		{ parseBlockCMPD($block) }		# CoMPounD words
		#SPECWORD
		if	($block_type eq 'VOC')		{ parseBlockVOC($block) }		# VOCabulary
		if	($block_type eq 'HTMLRES')	{ parseBlockRES($block) }		# Embedded (HTML) RESources
	}
}
#XSI blocks contains the XOR Seed Information for the compiled file.
sub parseBlockXSI($){
	my $block = shift;
	#Read initial seed value and increment value
	$Encryption_Seed		= unpack('C', substr($block, 0, 1));
	$Encryption_Increment	= unpack('C', substr($block, 1, 1));
	print $File_Log "\t($Encryption_Seed+$Encryption_Increment)\n";
}
#OBJect blocks contain all the objects of the game
sub parseBlockOBJ($){
	my $block	= shift;
	my $length	= length($block);
	#Objects are stored sequentially with no dividers or indication of how many there are;
	#We need to read the entire block sequentially.
	my $pos		= 0;
	my $found	= 0;				# Number of objects found
	while ($pos < $length) {
		#Object Header:
		# 0		Object type
		# 1-2	Object ID (UINT16)
		# 3-4	Unknown (often the same as size)
		# 5-6	Size (UINT16)
		my $type			= unpack('C', substr($block, $pos, 1));
		my $id				= unpack('S', substr($block, $pos + 1, 2));
		my $unknown			= unpack('S', substr($block, $pos + 3, 2));
		my $size			= unpack('S', substr($block, $pos + 5, 2));
		#Read object data, stored in encrypted form
		my $data			= decrypt(substr($block, $pos + 7, $size));
		$pos	+= 7 + $size;
		$found++;
		#Check type and stored
		if		($type eq 1) { # Function
			#Functions are just code, so we simply store it
			print $File_Log "\tObj$id: function ($size bytes)\n"	if $Option_Verbose;
			print $File_Log "\t\tUnknown is $unknown\n"				if $Option_Verbose && $size != $unknown;
			$Objects[$id]	= {
				type		=> $type,
				code		=> $data
			};
		}
		elsif	($type eq 2) { # Meta-Object
			#Meta-Objects have their own sub-header, followed by data
			#  0-1	Workspace (UINT16)
			#  2-3	Flags (bitmap)
			#  4-5	Superclass count
			#  6-7	Property count
			#  8-9	offset to next free byte in prop area (UInt16): Not needed for decompile
			# 10-11	offset to end of static area, reset point (UInt16): Not needed for decompile
			# 12-13 size of 'static' (stored) properties (UInt16)
			my $workspace		= unpack('S', substr($data, 0, 2));
			my $flags			= unpack('S', substr($data, 2, 2));
			my $superclasses	= unpack('S', substr($data, 4, 2));
			my $properties		= unpack('S', substr($data, 6, 2));
			print $File_Log "\tObj$id: object ($size bytes) in $workspace with $superclasses parents and $properties properties\n"
				if $Option_Verbose;
			#Read superclasses, a list of UINT16 object ids
			my @superclass;
			for (my $i=0 ; $i<$superclasses ; $i++) {
				push @superclass, unpack('S', substr($data, 14 + 2*$i, 2));
			}
			#Parse properties
			my %property	= ();
			my $pos_data	= 14 + 2 * $superclasses;				# Skip past header and super classes
			$pos_data 		+= 2 * $properties if $flags & 2;	# Skip past property index if needed
			for (my $i=0 ; $i<$properties ; $i++) {
				#Parse property header
				my $prop_id			= unpack('S',	substr($data, $pos_data + 0, 2));
				my $prop_type		= ord	(		substr($data, $pos_data + 2));
				my $prop_size		= unpack('S',	substr($data, $pos_data + 3, 2));
				my $prop_flag		= ord	(		substr($data, $pos_data + 5));
				my $prop_data		= 				substr($data, $pos_data + 6, $prop_size);
				#Store the relevant data
				$property{$prop_id}	= {
					type	=> $prop_type,
					data	=> $prop_data
				};
				print $File_Log "\t\tProp$prop_id ($prop_size bytes): ".namePropertyType($prop_type)." ($prop_flag)\n"
					if $Option_Verbose;
				$pos_data += 6 + $prop_size;
			}
			#Store the decompiled info
			$Objects[$id]	= {
				type		=> $type,
				workspace	=> $workspace,
				flags		=> {
					isClass		=> ($flags & 1),	# Is the object a class
					hasPropInd	=> ($flags & 2),	# Is there an encoded property index
					isModified	=> ($flags & 4)		# Modified by a newer definition
				},
				superclass	=> \@superclass,
				properties	=> \%property
			};
		}
		else{
			print $File_Log "\tObj$id: Unhandled type: $type\n";
			#TODO: Add translation of type
		}
	}
	print $File_Log "\tFound $found objects in total\n";
}
#ForMaT STRing block
sub parseBlockFMTSTR($){
	my $block	= shift;
	my $length	= length($block);
	#FMTSTR has a sub-header which contains the size of the block.
	my $size	= unpack('S', substr($block, 0, 2));
	$block		= decrypt(substr($block, 2));
	warn "FMTSTR block contains unparsed space" unless $size eq ($length - 2);
	#Compounds are stored sequentially with no dividers or indication of how many there are;
	#We need to read the entire block sequentially.
	my $pos		= 0;
	my $found	= 0;
	while ($pos < $size) {
		my $prop	= unpack('S', substr($block, $pos, 2));
		my $size	= unpack('S', substr($block, $pos + 2, 2));
		my $text	= substr($block, $pos + 4, $size - 2);
		$pos		+= 2 + $size;
		#TODO: Parse the text into a name for the property
		my $prep_rename;
		my $prep_name					= uniformName('fmt '.$text);
		$Translate_Property[$prop]		= $prep_name unless defined $Translate_Property[$prop];
		$prep_rename					= 1		unless $prep_name eq $Translate_Property[$prop];
		print $File_Log	"\tProp$prop: $prep_name"			if $prep_rename || $Option_Verbose;
		print $File_Log "\t -> ".nameObject($prep_name)		if $prep_rename;
		print $File_Log	"\t($text)\n"						if $prep_rename || $Option_Verbose;
		my $format	= "'$text' " . nameProperty($prop);
		push @Formats, $format;
		$found++;
	}
	print $File_Log "\tFound $found formated strings\n";
}
#REQuired Functionality block
sub parseBlockREQ($){
	my $block	= shift;
	my $length	= length($block);
	#Names and arguments for required functions are taken from detads by Daniel Schepler
	my @req_names	= [];
	$req_names[0]	= 'Me'; 
	$req_names[1]	= 'takeVerb'; 
	$req_names[2]	= 'strObj'; 
	$req_names[3]	= 'numObj'; 
	$req_names[4]	= 'pardon';
	$req_names[5]	= 'againVerb'; 
	$req_names[6]	= 'init'; 
	$req_names[7]	= 'preparse'; 
	$req_names[8]	= 'parseError';
	$req_names[9]	= 'commandPrompt'; 
	$req_names[10]	= 'parseDisambig'; 
	$req_names[11]	= 'parseError2';
	$req_names[12]	= 'parseDefault'; 
	$req_names[13]	= 'parseAskobj'; 
	$req_names[14]	= 'preparseCmd';
	$req_names[15]	= 'parseAskobjActor'; 
	$req_names[16]	= 'parseErrorParam'; 
	$req_names[17]	= 'commandAfterRead';
	$req_names[18]	= 'initRestore'; 
	$req_names[19]	= 'parseUnknownVerb'; 
	$req_names[20]	= 'parseNounPhrase';
	$req_names[21]	= 'postAction'; 
	$req_names[22]	= 'endCommand'; 
	$req_names[23]	= 'preCommand';
	$req_names[24]	= 'parseAskobjIndirect';
	my @req_args	= [];
	$req_args[7]	= ['cmd'];							# preparse
	$req_args[8]	= ['num', 'str'];					# parseError
	$req_args[9]	= ['type'];							# commandPrompt
	$req_args[10]	= ['nameString', 'objList'];		# parseDisambig
	$req_args[11]	= ['verb', 'dobj', 'prep', 'iobj'];	# parseError2
	$req_args[12]	= ['obj', 'prep'];					# parseDefault
	$req_args[13]	= ['verb'];							# parseAskobj
	$req_args[14]	= ['wordList'];						# preparseCmd
	$req_args[15]	= ['actor', 'verb'];				# parseAskobjActor
	$req_args[16]	= ['num', 'str'];					# parseErrorParam
	$req_args[17]	= ['type'];							# commandAfterRead
	$req_args[19]	= ['actor', 'wordlist', 'typelist', 'errnum'];				# parseUnknownVerb
	$req_args[20]	= ['wordlist', 'typelist', 'currentIndex', 'complainOnNoMatch', 'isActorCheck'];	# parseNounPhrase
	$req_args[21]	= ['actor', 'verb', 'dobj', 'prep', 'iobj', 'status'];		# postAction
	$req_args[22]	= ['actor', 'verb', 'dobj_list', 'prep', 'iobj', 'status'];	# endCommand
	$req_args[23]	= ['actor', 'verb', 'dobj_list', 'prep', 'iobj'];			# preCommand
	$req_args[24]	= ['actor', 'verb', 'prep', 'objectList'];					# parseAskobjIndirect
	#Required functions are stored as an array of UINT16 pointing to the ID of the implementing object; 65535 as null value
	#Exactly how many there are depends on the version of TADS; we currently know the names of 25.
	my $found	= $length / 2;
	if ($found > $#req_names + 1){
		my $message = "REQ: Found $found entries, only the first ". ($#req_names + 1) . " are processed";
		print $File_Log	"\t$message\n";
		warn $message;
		$found	= $#req_names + 1;
	}
	for my $i(0 .. $found){
		my $object	= unpack('S', substr($block, $i * 2, 2));
		unless ($object eq $Null_Value){
			print $File_Log	"\t$i:\tObj$object\t($req_names[$i])\n" if $Option_Verbose;
			print $File_Log	"\t$i:\tObj$object is named $Translate_Object[$object]\n"
				if defined $Translate_Object[$object] 
					&& $Translate_Object[$object] != $req_names[$i];
			$Translate_Object[$object]			= $req_names[$i];
			print $File_Log	"\t$i:\tObj$object has arguments\n"
				if defined $Translate_Object_Argument[$object];
			$Translate_Object_Argument[$object]	= $req_args[$i] if defined $req_args[$i];
		}
	}
}
#CoMPounD word blocks contains contractions for the token parser
sub parseBlockCMPD($){
	my $block	= shift;
	my $length	= length($block);
	#CMPD has a sub-header which contains the size of the block.
	my $size	= unpack('S', substr($block, 0, 2));
	$block		= decrypt(substr($block, 2));
	warn "CMPD block contains unparsed space" unless $size eq ($length - 2);
	#Compounds are stored sequentially with no dividers or indication of how many there are;
	#We need to read the entire block sequentially.
	my $pos		= 0;
	my $found	= 0;
	while ($pos < $size) {
		#Each CMPD record consists of 3 strings stored sequentially
		my $size1	= unpack('S', substr($block, $pos, 2));
		my $text1	= substr($block, $pos + 2, $size1 - 2);
		$pos		+= $size1;
		my $size2	= unpack('S', substr($block, $pos, 2));
		my $text2	= substr($block, $pos + 2, $size2 - 2);
		$pos		+= $size2;
		my $size3	= unpack('S', substr($block, $pos, 2));
		my $text3	= substr($block, $pos + 2, $size3 - 2);
		$pos		+= $size3;
		#Assemble and store the compound
		my $compound = "'$text1' '$text2' '$text3'";
		push @Compounds, $compound;
		$found++;
		print $File_Log	"\t$compound\n" if $Option_Verbose;
	}
	print $File_Log "\tFound $found compounds\n";
}
#VOCabulary blocks contain text properties that are used by the parser
sub parseBlockVOC($){
	my $block	= shift;
	my $length	= length($block);
	#Vocabulary properties are stored sequentially with no dividers or indication of how many there are;
	#We need to read the entire block sequentially.
	my $pos			= 0;
	my $found		= 0;
	my $found_total	= 0;
	while ($pos < $length) {
		#Each VOC record has a 10 byte header:
		# 0-1	Size of first vocabulary token
		# 2-3	Size of second vocabulary token, 0 if not used
		# 4-5	Property ID
		# 6-7	Object ID
		# 8-9	Flags
		#		2: Inherited
		my $size1	= unpack('S', substr($block, $pos + 0, 2));
		my $size2	= unpack('S', substr($block, $pos + 2, 2));
		my $prop_id	= unpack('S', substr($block, $pos + 4, 2));
		my $obj_id	= unpack('S', substr($block, $pos + 6, 2));
		my $flag	= unpack('S', substr($block, $pos + 8, 2));
		unless($flag & 2) {	# Skip inherited VOCabulary
			$found++;
			# Decrypt and extract the text string(s)
			my $data	= decrypt(substr($block, $pos + 10, $size1+$size2));
			my $text	= substr($data, 0, $size1);
			$text		.= ' '.substr($data, $size1, $size2) if ($size2 > 0);
			# Store in object's vocabulary list
			die "Vocabulary for undefined Object: Obj$obj_id"	unless defined $Objects[$obj_id];
			$Objects[$obj_id]{vocabulary}			= {}		unless $Objects[$obj_id]{vocabulary};
			$Objects[$obj_id]{vocabulary}{$prop_id}	= []		unless defined $Objects[$obj_id]{vocabulary}{$prop_id};
			push @{ $Objects[$obj_id]{vocabulary}{$prop_id} }, $text;
#			print $File_Log "\tObj$obj_id.prop$prop_id\t= '$text'\n";
		}
		#Advance to next record
		$pos += 10 + $size1 + $size2;
		$found_total++;
	}
	print $File_Log "\tFound $found vocabulary records ($found_total including inherited)\n";
}
#RESource blocks contain embedded files
sub parseBlockRES($) {
	#The block is divided into three distinct parts:
	#* Header, defining number of entries
	#* Metadata for each entry
	#* Embedded data for each entry
	my $block	= shift;
	my $length	= length($block);
	#Block header
	# 4 Bytes: Number of entries
	# 4 Bytes: Offset to where data begins
	my $entries	= unpack('L', substr($block, 0, 4));
	my $offset	= unpack('L', substr($block, 4, 4));
	#Read metadata and embedded data for each entry in one pass
	my $pos		= 8;
	for my $i (1 .. $entries){
		#Metadata
		my $data_pos	= unpack('L', substr($block, $pos, 4));
		my $size		= unpack('L', substr($block, $pos + 4, 4));
		my $name_size	= unpack('S', substr($block, $pos + 8, 2));
		my $name		= substr($block, $pos + 10, $name_size);
		$pos += $name_size + 10;
		print $File_Log "\t$name ($size bytes) at $data_pos\n";
		#Embedded data, only read when not in minimal mode
		unless ($Option_Minimal){
			#TODO: Make directory
			my $file_resource;
			open($file_resource, "> :raw :bytes", $FileName_Path . $name)
				|| die "$0: can't open ".$FileName_Path . $name . " in write-open mode: $!";
			print $file_resource substr($block, $data_pos + $offset, $size);
			close $file_resource;
		}
	}
}
##Analyzing
sub analyze(){
	print $File_Log "Analyzing Actions\n";
	analyzeActions();
	print $File_Log "Analyzing Function Code Segments\n";
	analyzeFunctionCode();
	print $File_Log "Analyzing Property Code Segments\n";
	analyzePropertyCode();
}
#Look through all objects, trying to find actions and verbs
sub analyzeActions(){
	#Actions aren't explicitly numbered so we keep a running tally
	my $action	= 0;
	for my $obj (0 .. $#Objects) {
		#Not all Object ID's are actually used
		next unless defined $Objects[$obj];
		#Not all objects have properties
		next unless defined $Objects[$obj]{properties};
		#Look through all properties
		for my $prop ( keys %{ $Objects[$obj]{properties} } ) {
			my $type	= $Objects[$obj]{properties}{$prop}{type};
			unless (defined $type) {
				print $File_Log "\tUnable to analyze $obj.$prop - Missing type";
				warn "Unable to analyze $obj.$prop - Missing type";
				next;
			}
			#TPL2 contains the action defintions we are looking for
			next unless namePropertyType($type) eq 'tpl2';
			my $data	= $Objects[$obj]{properties}{$prop}{data};
			unless (defined $data) {
				print $File_Log "\tUnable to analyze $obj.$prop - Missing data";
				warn "Unable to analyze $obj.$prop - Missing data";
				next;
			}
			#Generate a name the object has a verb (prop id 8)
			my $action_name	= "Action$action";
			$action_name	= uniformName(propertyString($obj, 8))	if (defined $Objects[$obj]{properties}{8});
			my $header_needed	= 1;
			print $File_Log "\t$action\tObj$obj\n"			if $Option_Verbose;
			undef $header_needed							if $Option_Verbose;
			#Try to rename action
			$Translate_Action[$action]	= $action_name unless defined $Translate_Action[$action];
			my $action_rename;
			$action_rename				= 1 	unless $action_name eq $Translate_Action[$action];
			print $File_Log "\t$action\tObj$obj\n"			if $action_rename && $header_needed;
			print $File_Log	"\t\tAction: $action_name"		if $action_rename || $Option_Verbose;
			print $File_Log "\t -> ".nameAction($action)	if $action_rename;
			print $File_Log	"\n"							if $action_rename || $Option_Verbose;
			undef $header_needed							if $action_rename;
			#Try to rename verb object
			my $verb_name	= $action_name."Verb";
			$Translate_Object[$obj]		= $verb_name unless defined $Translate_Object[$obj];
			my $verb_rename;
			$verb_rename				= 1		unless $verb_name eq $Translate_Object[$obj];
			print $File_Log "\t$action\tObj$obj\n"			if $verb_rename && $header_needed;
			print $File_Log	"\t\tObject: $verb_name"		if $verb_rename || $Option_Verbose;
			print $File_Log "\t -> ".nameObject($obj)		if $verb_rename;
			print $File_Log	"\n"							if $verb_rename || $Option_Verbose;
			undef $header_needed							if $verb_rename;
			#Templates for prepositions
			my $templates	= ord(substr($data, 0));
			for (my $i=0 ; $i < $templates ; $i++) {
				#Read identifiers for template
				my $prep_obj	= unpack('S', substr($data, $i * 16 + 1, 2));	# Preposition object
				my $ver_io_prop	= unpack('S', substr($data, $i * 16 + 3, 2));	# IndrectObject verify property
				my $exc_io_prop	= unpack('S', substr($data, $i * 16 + 5, 2));	# IndrectObject execute property
				my $ver_do_prop	= unpack('S', substr($data, $i * 16 + 7, 2));	# DirectObject verify property
				my $exc_do_prop	= unpack('S', substr($data, $i * 16 + 9, 2));	# DirectObject execute property
				#5 extra bytes at the end, which seems to be at least in part flag data.
				#Try to rename the preposition object
				my $prep_name;
				my $subheader_needed	= 1;
				unless ($prep_obj eq $Null_Value){ #Null-value
					$prep_name						= uniformName(propertyString($prep_obj, 8));
					$Translate_Object[$prep_obj]	= $prep_name unless defined $Translate_Object[$prep_obj];
					my $prep_rename;
					$prep_rename					= 1		unless $prep_name eq $Translate_Object[$prep_obj];
					print $File_Log "\t$action\tObj$obj\n"					if $prep_rename && $header_needed;
					print $File_Log	"\t\t$prep_name($prep_obj):"	if $prep_rename || $Option_Verbose;
					print $File_Log "\t -> ".nameObject($prep_name)			if $prep_rename;
					print $File_Log	"\n"									if $prep_rename || $Option_Verbose;
					undef $header_needed									if $prep_rename;
					undef $subheader_needed									if $prep_rename || $Option_Verbose;
				}
				if ($ver_io_prop) { #Indirect Object Verification
					#Property Arguments
					@{ $Translate_Property_Argument[$ver_io_prop] }	= ('actor');
					#Property Rename
					my $ver_io_name	= uniformName('Ver Io '.$action_name);
					$Translate_Property[$ver_io_prop]	= $ver_io_name unless defined $Translate_Property[$ver_io_prop];
					my $ver_io_rename;
					$ver_io_rename						= 1		unless $ver_io_name eq $Translate_Property[$ver_io_prop];
					print $File_Log "\t$action\tObj$obj\n"						if $ver_io_rename && $header_needed;
					print $File_Log	"\t\t$prep_name:\n"							if $subheader_needed && not $prep_obj eq $Null_Value
																					&& ($ver_io_rename || $Option_Verbose);
					print $File_Log	"\t\tNoPrep:\n"								if $subheader_needed && $prep_obj eq $Null_Value
																					&& ($ver_io_rename || $Option_Verbose);
					print $File_Log	"\t\t\t$ver_io_prop\tVerIo\t$ver_io_name"	if $ver_io_rename || $Option_Verbose;
					print $File_Log "\t -> ".nameProperty($ver_io_prop)			if $ver_io_rename;
					print $File_Log	"\n"										if $ver_io_rename || $Option_Verbose;
					undef $header_needed										if $ver_io_rename;
					undef $subheader_needed										if $ver_io_rename || $Option_Verbose;
				}
				if ($exc_io_prop) { #Indirect Object Execution
					#Property Arguments
					@{ $Translate_Property_Argument[$exc_io_prop] }	= ('actor', 'dobj');
					#Property Rename
					my $exc_io_name	= uniformName('Io '.$action_name);
					$Translate_Property[$exc_io_prop]	= $exc_io_name unless defined $Translate_Property[$exc_io_prop];
					my $exc_io_rename;
					$exc_io_rename						= 1		unless $exc_io_name eq $Translate_Property[$exc_io_prop];
					print $File_Log "\t$action\tObj$obj\n"						if $exc_io_rename && $header_needed;
					print $File_Log	"\t\t$prep_name:\n"							if $subheader_needed && not $prep_obj eq $Null_Value
																					&& ($exc_io_rename || $Option_Verbose);
					print $File_Log	"\t\tNoPrep:\n"								if $subheader_needed && $prep_obj eq $Null_Value
																					&& ($exc_io_rename || $Option_Verbose);
					print $File_Log	"\t\t\t$exc_io_prop\tIo\t\t$exc_io_name"	if $exc_io_rename || $Option_Verbose;
					print $File_Log "\t -> ".nameProperty($exc_io_prop)			if $exc_io_rename;
					print $File_Log	"\n"										if $exc_io_rename || $Option_Verbose;
					undef $header_needed										if $exc_io_rename;
					undef $subheader_needed										if $exc_io_rename || $Option_Verbose;
				}
				if ($ver_do_prop) { #Direct Object Verification
					#Property Arguments
					@{ $Translate_Property_Argument[$ver_do_prop] }	= ('actor', 'iobj')	if ($exc_io_prop);
					@{ $Translate_Property_Argument[$ver_do_prop] }	= ('actor')		unless ($exc_io_prop);
					#Property Rename
					my $ver_do_name	= uniformName('Ver Do '.$action_name);
					$Translate_Property[$ver_do_prop]	= $ver_do_name unless defined $Translate_Property[$ver_do_prop];
					my $ver_do_rename;
					$ver_do_rename						= 1		unless $ver_do_name eq $Translate_Property[$ver_do_prop];
					print $File_Log "\t$action\tObj$obj\n"						if $ver_do_rename && $header_needed;
					print $File_Log	"\t\t$prep_name:\n"							if $subheader_needed && not $prep_obj eq $Null_Value
																					&& ($ver_do_rename || $Option_Verbose);
					print $File_Log	"\t\tNoPrep:\n"								if $subheader_needed && $prep_obj eq $Null_Value
																					&& ($ver_do_rename || $Option_Verbose);
					print $File_Log	"\t\t\t$ver_do_prop\tVerDo\t$ver_do_name"	if $ver_do_rename || $Option_Verbose;
					print $File_Log "\t -> ".nameProperty($ver_do_prop)			if $ver_do_rename;
					print $File_Log	"\n"										if $ver_do_rename || $Option_Verbose;
					undef $header_needed										if $ver_do_rename;
					undef $subheader_needed										if $ver_do_rename || $Option_Verbose;
				}
				if ($exc_do_prop) { #Direct Object Execution
					#Property Arguments
					@{ $Translate_Property_Argument[$exc_do_prop] }	= ('actor', 'iobj')	if ($exc_io_prop);
					@{ $Translate_Property_Argument[$exc_do_prop] }	= ('actor')		unless ($exc_io_prop);
					#Property Rename
					my $exc_do_name	= uniformName('Do '.$action_name);
					$Translate_Property[$exc_do_prop]	= $exc_do_name unless defined $Translate_Property[$exc_do_prop];
					my $exc_do_rename;
					$exc_do_rename						= 1		unless $exc_do_name eq $Translate_Property[$exc_do_prop];
					print $File_Log "\t$action\tObj$obj\n"						if $exc_do_rename && $header_needed;
					print $File_Log	"\t\t$prep_name:\n"							if $subheader_needed && not $prep_obj eq $Null_Value
																					&& ($exc_do_rename || $Option_Verbose);
					print $File_Log	"\t\tNoPrep:\n"								if $subheader_needed && $prep_obj eq $Null_Value
																					&& ($exc_do_rename || $Option_Verbose);
					print $File_Log	"\t\t\t$exc_do_prop\tDo\t\t$exc_do_name"	if $exc_do_rename || $Option_Verbose;
					print $File_Log "\t -> ".nameProperty($exc_do_prop)			if $exc_do_rename;
					print $File_Log	"\n"										if $exc_do_rename || $Option_Verbose;
					undef $header_needed										if $exc_do_rename;
					undef $subheader_needed										if $exc_do_rename || $Option_Verbose;
				}
			}
			$action++;
		}

	}
}
#Look through all objects, analyzing the code segments of function objects
sub analyzeFunctionCode(){
	for my $obj (0 .. $#Objects) {
		#Not all Object ID's are actually used
		next unless defined $Objects[$obj];
		#Not all objects have properties
		next unless $Objects[$obj]{type} eq 1;
		my $codeblock = $Objects[$obj]{code};
		#TODO: Decode the codeblock and store the result
	}
}
#Look through all objects, analyzing the code segments of code properties
sub analyzePropertyCode(){
	for my $obj (0 .. $#Objects) {
		#Not all Object ID's are actually used
		next unless defined $Objects[$obj];
		#Not all objects have properties
		next unless defined $Objects[$obj]{properties};
		#Look through all properties
		for my $prop ( keys %{ $Objects[$obj]{properties} } ) {
			my $type	= $Objects[$obj]{properties}{$prop}{type};
			unless (defined $type) {
				print $File_Log "\tUnable to analyze $obj.$prop - Missing type";
				warn "Unable to analyze $obj.$prop - Missing type";
				next;
			}
			#Look for code properties
			next unless namePropertyType($type) eq 'code';
			my $codeblock = $Objects[$obj]{properties}{$prop}{data};
			unless (defined $codeblock) {
				print $File_Log "\tUnable to analyze $obj.$prop - Missing data";
				warn "Unable to analyze $obj.$prop - Missing data";
				next;
			}
			#TODO: Decode the codeblock and store the result
		}
	}
}
#Convert text into uniform naming without spaces or quotes
sub uniformName($){
	my $text	= lc(shift);				# Lower case
	$text		=~ s/\s+/ /;				# Convert all whitespace to spaces, and trim multiples
	$text		=~ s/[-_'\"]//g;				# Trim all unwanted characters
	$text		=~ s/^\s+|\s+$//g;			# Trim leading/trailing whitespace
	$text		=~ s/ (.)/uc($1)/ge;		# Remove spaces, capitalizing the next letter
	return $text;
}
#Converts a property of a given object to a string
sub propertyString($$){
	my $obj		= shift;
	my $prop	= shift;
	die "propertyString needs both Object and Property id"		unless defined $obj && defined $prop;
	die "Can't access property $prop on undefined object $obj"	unless defined $Objects[$obj];
	my $type	= $Objects[$obj]{properties}{$prop}{type};
	my $data	= $Objects[$obj]{properties}{$prop}{data};
	unless (defined $type && defined $data) {
		warn "Unable to convert Obj$obj.Prop$prop to string; missing type or data";
		return 'Obj$obj.Prop$prop (ERROR)';
	}
	#Hand over the working to the decoding function
	return decodeProperty($type, $data);
}
#Converts an array into a comma-separated string with an optional value delimiter
sub arrayString($;$){
	my $listref		= shift;
	my $delimiter	= shift;
	$delimiter		= '' unless defined $delimiter;
	my @list		= @{$listref};
	my $text = '';
	for my $i (0 .. $#list) {
		$text	.= ', ' if $i > 0;
		$text	.= $delimiter . $list[$i] . $delimiter;
	}
	return $text;
}
##Decoding
#Decode a property given it's type; lists need to be interpreted recursively
sub decodeProperty($$);
sub decodeProperty($$) {
	my $type	= shift;
	my $data	= shift;
	#Default value is the name of the property; This covers:
	# 4	BASEPTR
	# 5	NIL		type is the same as value
	# 6	CODE	Code is too long to print; use decodeCode for detailed code breakdown
	# 8	TRUE	type is the same as value
	#11	TPL
	#14	DEMAND
	#15	SYNONYM
	#16	REDIR
	#17	TPL2
	my $text	= namePropertyType($type);
	if (namePropertyType($type) eq 'number')	{ $text	= unpack('l', $data) }							# 1
	if (namePropertyType($type) eq 'object')	{ $text	= objectName(unpack('S', $data)) }				# 2
	if (namePropertyType($type) eq 's-string')	{ $text	= "'".substr($data, 2)."'" }					# 3
	if (namePropertyType($type) eq 'd-string')	{ $text	= '"'.substr($data, 2).'"' }					# 9
	if (namePropertyType($type) eq 'fnaddr')	{ $text	= '&'.objectName(unpack('S', $data)) }			# 10
	if (namePropertyType($type) eq 'property')	{ $text	= propertyName(unpack('S', $data)) }			# 13
	#Lists (7) require some special handling, as they are recursive
	if (namePropertyType($type) eq 'list'){
		#Only the total size is given; each entry has to be read sequentially from the start.
		my @entries;
		my $size	= unpack('S', substr($data, 0, 2));
		my $pos		= 2;
		while ($pos < $size){
			my $entry_type	=	ord(substr($data, $pos));
			my $entry_data;
			my $entry_size;
			$pos++;	# Adjust for typecode
			if 		(namePropertyType($type) eq 'number') {
				#Fixed 1 + 4 byte size
				$entry_data	= substr($data, $pos, 4);
				$entry_size	= 4;
			}
			elsif (	namePropertyType($type) eq 'object'
				||	namePropertyType($type) eq 'fnaddr'
				||	namePropertyType($type) eq 'property') {
				#Fixed 1 + 2 byte size
				$entry_data	= substr($data, $pos, 2);
				$entry_size	= 2;
			}
			elsif (	namePropertyType($type) eq 'nil'
				||	namePropertyType($type) eq 'true') {
				#Fixed 1 + 0 byte size
				$entry_size	= 0;
			}
			elsif (	namePropertyType($type) eq 's-string'
				||	namePropertyType($type) eq 'd-string'
				||	namePropertyType($type) eq 'list') {
				#Variable size;
				#We need to peek into the element to find the size;
				#Remember to *not* chop off the size
				$entry_size 	= unpack('S', substr($data, $pos, 2));
				$entry_data		= substr($data, $pos, $entry_size);
			}
			else {
				die "Illegal list entry: ".namePropertyType($entry_type)." ($entry_type)";
			}
			$pos 	+= $entry_size; 
			push @entries, decodeProperty($entry_type, $entry_data);
		}
		$text = "[".arrayString(\@entries)."]";
	}
	return $text;
}
##Main Program Loop
#Parse command-line arguments
for (;;) {
	if		($#ARGV >= 1 && $ARGV[0] eq '-s') {		# Read symbol mapping file
		$FileName_Mapping	= $ARGV[1];
		splice(@ARGV, 0, 2);
	}
	elsif	($#ARGV >= 0 && $ARGV[0] eq '+s') {		# Create symbol file template
		$Option_Generate	= 1;
		splice(@ARGV, 0, 1);
	}
	elsif($#ARGV >= 0 && $ARGV[0] eq '-v'){			# Verbose
		$Option_Verbose		= 1;
		splice(@ARGV, 0, 1);
	}
	elsif($#ARGV >= 0 && $ARGV[0] eq '-m'){			# Minimalist mode
		$Option_Minimal		= 1;
		splice(@ARGV, 0, 1);
	}
	else { last }
}
$FileName_Input	= $ARGV[0];	# There should be only one argument left, giving the name of the file to parse.
die "Use: tads2 [options] file.taf\n$Options" if ($#ARGV != 0);	# Too many unparsed arguments

#Determine names to use
$FileName_Path	= './';	# Default to no directory
if ($ARGV[0] =~ m/([\w\s]*)\.gam/i){	# Use the name of the input file if possible
	$FileName_Path		= $1 . '/'		unless defined $Option_Minimal;
	$FileName_Generate	= $1 . '.sym'	if defined $Option_Generate;
	$FileName_Output	= $1 . '.t';
	$FileName_Log		= $1 . '.log';
}
else{
	$FileName_Path		= 'decoded/'	unless defined $Option_Minimal;
	$FileName_Output	= 'source.t';
	$FileName_Log		= 'decompile.log';
	$FileName_Generate	= $1 . '.sym'	if defined $Option_Generate;
}

#Some sanity checking
die "$FileName_Input is not a valid file"	unless -f $FileName_Input;
die "Overwriting existing symbol file with autogenerated is not supported in minimal mode"
	if defined $FileName_Generate && $Option_Minimal && -e $FileName_Generate ;

#Create output path
mkdir $FileName_Path						unless -e $FileName_Path;
die "$FileName_Path is not a valid path"	unless -d $FileName_Path;

#Open file handles
open($File_Input, "< :raw :bytes", $FileName_Input)
	|| die("Couldn't open $FileName_Input for reading.");
open($File_Log, "> :raw :bytes :unix", $FileName_Path . $FileName_Log) # Use :unix to flush the log as we write to it
	|| die "$0: can't open " . $FileName_Path . $FileName_Log . " for writing: $!";
open($File_Output, "> :raw :bytes", $FileName_Path . $FileName_Output)
	|| die "$0: can't open " . $FileName_Path . $FileName_Output . "for writing: $!";

#Process the game archive
parseHeader();									# Read header and determine version/type of file
parseFile();									# Parse the input file into the local data structures
close($File_Input);
preloadMapping();								# Load mapping defaults
parseMapping() if defined $FileName_Mapping;	# Read symbol file if called for
analyze();
generateMapping() if $Option_Generate;			# Generate symbol file if called for

#TODO: Generate source code

#Close file output
close($File_Output);
close($File_Log);